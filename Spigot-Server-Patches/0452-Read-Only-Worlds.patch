From fdc853fa44fbd654442e4d1120b334ed72327569 Mon Sep 17 00:00:00 2001
From: cryptite <cryptite@gmail.com>
Date: Tue, 23 Jul 2019 14:00:08 -0500
Subject: [PATCH] Read Only Worlds


diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 8db5c6a3..0d8d542f 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1118,11 +1118,14 @@ public abstract class MinecraftServer implements IAsyncTaskHandler, IMojangStati
                     throw new ReportedException(crashreport);
                 }
 
-                this.methodProfiler.exit();
-                this.methodProfiler.enter("tracker");
-                if (playerList.players.size() > 0) worldserver.getTracker().updatePlayers(); // Paper - No players, why spend time tracking them? (See patch)
-                this.methodProfiler.exit();
-                this.methodProfiler.exit();
+                if (!worldserver.getWorld().isReadOnly()) {
+                    this.methodProfiler.exit();
+                    this.methodProfiler.enter("tracker");
+                    if (!playerList.players.isEmpty())
+                        worldserver.getTracker().updatePlayers(); // Paper - No players, why spend time tracking them? (See patch)
+                    this.methodProfiler.exit();
+                    this.methodProfiler.exit();
+                }
                 worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
             }
         }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 8af54019..d8d77e74 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -1,7 +1,5 @@
 package net.minecraft.server;
 
-import co.aikar.timings.Timings;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.util.concurrent.ListenableFuture;
 import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
@@ -22,10 +20,7 @@ import org.apache.logging.log4j.Logger;
 import java.util.logging.Level;
 
 import org.bukkit.WeatherType;
-import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.util.HashTreeSet;
 
-import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.event.weather.LightningStrikeEvent;
 // CraftBukkit end
@@ -293,9 +288,13 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
         timings.doChunkUnload.stopTiming(); // Spigot
         this.methodProfiler.exitEnter("tickPending");
-        timings.scheduledBlocks.startTiming(); // Paper
-        this.q();
-        timings.scheduledBlocks.stopTiming(); // Paper
+
+        if (!getWorld().isReadOnly()) {
+            timings.scheduledBlocks.startTiming(); // Paper
+            this.q();
+            timings.scheduledBlocks.stopTiming(); // Paper
+        }
+
         this.methodProfiler.exitEnter("tickBlocks");
         timings.chunkTicks.startTiming(); // Paper
         this.n_();
@@ -478,7 +477,9 @@ public class WorldServer extends World implements IAsyncTaskHandler {
                 int k = chunk.locZ * 16;
 
                 this.methodProfiler.exitEnter("checkNextLight");
-                chunk.x();
+                if (!getWorld().isReadOnly()) {
+                    chunk.x();
+                }
                 this.methodProfiler.exitEnter("tickChunk");
                 chunk.d(false);
                 if ( !chunk.areNeighborsLoaded( 1 ) ) continue; // Spigot
@@ -528,40 +529,42 @@ public class WorldServer extends World implements IAsyncTaskHandler {
                     }
                 }
 
-                this.methodProfiler.exitEnter("tickBlocks");
-                timings.chunkTicksBlocks.startTiming(); // Paper
-                if (i > 0) {
-                    ChunkSection[] achunksection = chunk.getSections();
-                    int i1 = achunksection.length;
-
-                    for (int j1 = 0; j1 < i1; ++j1) {
-                        ChunkSection chunksection = achunksection[j1];
-
-                        if (chunksection != Chunk.a && chunksection.b()) {
-                            for (int k1 = 0; k1 < i; ++k1) {
-                                this.m = this.m * 3 + 1013904223;
-                                int l1 = this.m >> 2;
-                                int i2 = l1 & 15;
-                                int j2 = l1 >> 8 & 15;
-                                int k2 = l1 >> 16 & 15;
-                                IBlockData iblockdata = chunksection.getType(i2, k2, j2);
-                                Fluid fluid = chunksection.b(i2, k2, j2);
-
-                                this.methodProfiler.enter("randomTick");
-                                if (iblockdata.t()) {
-                                    iblockdata.b((World) this, new BlockPosition(i2 + j, k2 + chunksection.getYPosition(), j2 + k), this.random);
+                if (!getWorld().isReadOnly()) {
+                    this.methodProfiler.exitEnter("tickBlocks");
+                    timings.chunkTicksBlocks.startTiming(); // Paper
+                    if (i > 0) {
+                        ChunkSection[] achunksection = chunk.getSections();
+                        int i1 = achunksection.length;
+
+                        for (int j1 = 0; j1 < i1; ++j1) {
+                            ChunkSection chunksection = achunksection[j1];
+
+                            if (chunksection != Chunk.a && chunksection.b()) {
+                                for (int k1 = 0; k1 < i; ++k1) {
+                                    this.m = this.m * 3 + 1013904223;
+                                    int l1 = this.m >> 2;
+                                    int i2 = l1 & 15;
+                                    int j2 = l1 >> 8 & 15;
+                                    int k2 = l1 >> 16 & 15;
+                                    IBlockData iblockdata = chunksection.getType(i2, k2, j2);
+                                    Fluid fluid = chunksection.b(i2, k2, j2);
+
+                                    this.methodProfiler.enter("randomTick");
+                                    if (iblockdata.t()) {
+                                        iblockdata.b((World) this, new BlockPosition(i2 + j, k2 + chunksection.getYPosition(), j2 + k), this.random);
+                                    }
+
+                                    if (fluid.h()) {
+                                        fluid.b(this, new BlockPosition(i2 + j, k2 + chunksection.getYPosition(), j2 + k), this.random);
+                                    }
+
+                                    this.methodProfiler.exit();
                                 }
-
-                                if (fluid.h()) {
-                                    fluid.b(this, new BlockPosition(i2 + j, k2 + chunksection.getYPosition(), j2 + k), this.random);
-                                }
-
-                                this.methodProfiler.exit();
                             }
                         }
                     }
+                    timings.chunkTicksBlocks.stopTiming(); // Paper
                 }
-                timings.chunkTicksBlocks.stopTiming(); // Paper
             }
 
             this.methodProfiler.exit();
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 457aa5a3..0be13b52 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -87,6 +87,7 @@ public class CraftWorld implements World {
     private int ambientSpawn = -1;
     private int chunkLoadCount = 0;
     private int chunkGCTickCount;
+    private boolean readOnly;
 
     // Paper start - Provide fast information methods
     public int getEntityCount() {
@@ -975,6 +976,14 @@ public class CraftWorld implements World {
         return Difficulty.getByValue(this.getHandle().getDifficulty().ordinal());
     }
 
+    public boolean isReadOnly() {
+        return readOnly;
+    }
+
+    public void setReadOnly(boolean readOnly) {
+        this.readOnly = readOnly;
+    }
+
     public BlockMetadataStore getBlockMetadata() {
         return blockMetadata;
     }
-- 
2.17.1.windows.2

